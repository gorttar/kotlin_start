package course.ps2;

import static org.gorttar.test.HelpersKt.fail;

public class PayInAYearBisection {
    /**
     * В предыдущей задаче месячный платёж был кратен 10 рублям. Зачем это было сделано? Ты можешь попробовать запустить
     * решение с другой кратностью (например, с точностью до рубля или до копейки). Будет ли оно работать? Должно, но можно
     * заметить, что код работает очень долго, особенно для случая большого баланса и процентов.
     * <p>
     * Но тогда как же посчитать платёж более точно и быстро одновременно? Можно сделать это с помощью техники, которая
     * была рассказана в лекции - поиском делением отрезка пополам!
     * <p>
     * Параметры функции:
     * <p>
     *
     * @param balance            сумма долга по кредитной карте
     * @param annualInterestRate годовая ставка в виде доли
     *                           (если ставка 18%, то значение параметра будет равно 0.18)
     * @return строка, в которой будет написан минимальный фиксированный месячный платёж, например:
     * <p>
     * *    "Lowest Payment: 29157.1"
     * <p>
     * Как и в предыдущей задаче, мы ищем минимальный фиксированный месячный платёж достаточный, чтобы погасить долг по
     * кредитной карте за 12 месяцев. Какой может быть нижняя граница интервала поиска? 0 рублей - очевидный ответ, но есть
     * лучшая оценка. Если предположить, что банк не берёт процентов, то надо будет гасить по одной двенадцатой суммы долга
     * каждый месяц. Одна двенадцатая от суммы долга - хорошая нижняя граница интервала поиска.
     * <p>
     * Какой может быть верхняя граница интервала поиска? Представим, что вместо ежемесячных выплат, нужно погасить весь
     * долг со всеми начисленными процентами в конце года. Очевидно, что при этом начисленный процент будет максимален,
     * поэтому одна двенадцатая от суммы долга со всеми начисленными процентами на конец года будет явно больше искомого
     * платежа.
     * <p>
     * Математически:
     * <p>
     * *    Месячная ставка = [annualInterestRate] / 12.0
     * *    нижняя граница интервала поиска = [balance] / 12.0
     * *    верхняя граница интервала поиска = ([balance] * (1 + Месячная ставка).pow(12)) / 12.0
     * <p>
     * Необходимо написать функцию, которая использует эти границы и поиск методом деления отрезка пополам (подробности см.
     * https://ru.wikipedia.org/wiki/Метод_бисекции) для поиска минимального платежа с точностью до копейки (больше никаких
     * платежей, кратных 10 рублям)
     * <p>
     * Имей ввиду, что без использования метода деления отрезка пополам функция не пройдёт тесты, так как время её
     * исполнения ограничено 10 секундами. Кроме того, ответ должен быть с точностью до копейки, то есть вместо
     * "Lowest Payment: 29157.09957843" должно быть "Lowest Payment: 29157.1"
     * <p>
     * Заметка: тесты достаточно снисходительны к ответу, возвращаемому функцией. Если он будет на пару копеек больше или
     * меньше - ничего страшного, такой ответ пройдёт тест
     * <p>
     * Ниже прилагаются примеры тестов.
     * *    Тест 1
     * *        Входные параметры:
     * *            [balance] = 320000.0
     * *            [annualInterestRate] = 0.2
     * *        Ожидаемый результат: "Lowest Payment: 29157.1"
     * <p>
     * *    Тест 2
     * *        Входные параметры:
     * *            [balance] = 999999.0
     * *            [annualInterestRate] = 0.18
     * *        Ожидаемый результат: "Lowest Payment: 90325.03"
     * <p>
     * Для проверки задания запускаешь main из файла src/test/kotlin/course/ps2/Problem3Test.kt и смотришь вывод.
     * Он должен быть зелёным, если всё верно
     */
    public static String payInAYearBisection(Double balance, Double annualInterestRate) {
        return fail();
    }
}