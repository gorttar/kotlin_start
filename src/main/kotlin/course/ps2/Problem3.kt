package course.ps2

import lib.test.FAIL
import lib.test.orElse
import lib.test.passTo
import lib.test.shouldBe
import lib.test.withTimeLimit

/**
 * В предыдущей задаче месячный платёж был кратен 10 рублям. Зачем это было сделано? Ты можешь попробовать запустить
 * решение с другой кратностью (например, с точностью до рубля или до копейки). Будет ли оно работать? Должно, но можно
 * заметить, что код работает очень долго, особенно для случая большого баланса и процентов.
 *
 * Но тогда как же посчитать платёж более точно и быстро одновременно? Можно сделать это с помощью техники, которая
 * была рассказана в лекции - поиском делением отрезка пополам!
 *
 * Параметры функции:
 *
 * [balance]            сумма долга по кредитной карте
 * [annualInterestRate] годовая ставка в виде доли
 * *    (если ставка 18%, то [annualInterestRate] будет равно 0.18)
 *
 * Как и в предыдущей задаче, мы ищем минимальный фиксированный месячный платёж достаточный, чтобы погасить долг по
 * кредитной карте за 12 месяцев. Какой может быть нижняя граница интервала поиска? 0 рублей - очевидный ответ, но есть
 * лучшая оценка. Если предположить, что банк не берёт процентов, то надо будет гасить по одной двенадцатой суммы долга
 * каждый месяц. Одна двенадцатая от суммы долга - хорошая нижняя граница интервала поиска.
 *
 * Какой может быть верхняя граница интервала поиска? Представим, что вместо ежемесячных выплат, нужно погасить весь
 * долг со всеми начисленными процентами в конце года. Очевидно, что при этом начисленный процент будет максимален,
 * поэтому одна двенадцатая от суммы долга со всеми начисленными процентами на конец года будет явно больше искомого
 * платежа.
 *
 * Математически:
 *
 * *    Месячная ставка = [annualInterestRate] / 12.0
 * *    нижняя граница интервала поиска = [balance] / 12.0
 * *    верхняя граница интервала поиска = ([balance] * (1 + Месячная ставка).pow(12)) / 12.0
 *
 * Необходимо написать функцию, которая использует эти границы и поиск методом деления отрезка пополам (подробности см.
 * https://ru.wikipedia.org/wiki/Метод_бисекции) для поиска минимального платежа с точностью до копейки (больше никаких
 * платежей, кратных 10 рублям)
 *
 * Имей ввиду, что без использования метода деления отрезка пополам функция не пройдёт тесты, так как время её
 * исполнения ограничено 10 секундами. Кроме того, ответ должен быть с точностью до копейки, то есть вместо
 * "Lowest Payment: 29157.09957843" должно быть "Lowest Payment: 29157.1"
 *
 * Заметка: тесты достаточно снисходительны к ответу, возвращаемому функцией. Если он будет на пару копеек больше или
 * меньше - ничего страшного, такой ответ пройдёт тест
 *
 * Ниже прилагаются примеры тестов.
 * *    Тест 1
 * *        Входные параметры:
 * *            [balance] = 320000.0
 * *            [annualInterestRate] = 0.2
 * *        Ожидаемый результат: "Lowest Payment: 29157.1"
 *
 * *    Тест 2
 * *        Входные параметры:
 * *            [balance] = 999999.0
 * *            [annualInterestRate] = 0.18
 * *        Ожидаемый результат: "Lowest Payment: 90325.03"
 *
 * Для проверки задания запускаешь [main] и смотришь вывод. Он должен быть зелёным, если всё верно
 */
fun payInAYearBisection(balance: Double, annualInterestRate: Double): String {
    FAIL
}

/**
 * запусти, чтобы протестировать функцию [payInAYearBisection]
 */
fun main() {
    (sequenceOf(
            PayInAYearCase(320000.0, 0.2, "Lowest Payment: 29157.1"),
            PayInAYearCase(999999.0, 0.18, "Lowest Payment: 90325.03")
    ) + bisectionCases.shuffled().asSequence().take(10)).forEach { (args, expected) ->
        args passTo { payInAYearBisection(balance, annualInterestRate) } withTimeLimit 10 shouldBe { actual ->
            val expectedRange = (expected.payment() - 0.02).round(2)..(expected.payment() + 0.02).round(2)
            (actual.replace("^.*\\.".toRegex(), "").length <= 2 && actual.payment() in expectedRange) orElse
                    "Lowest Payment in $expectedRange"
        }
    }
}

private fun String.payment() = removePrefix("Lowest Payment: ").toDouble()